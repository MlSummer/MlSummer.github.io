<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis</title>
      <link href="/2022/10/06/technology/Redis/"/>
      <url>/2022/10/06/technology/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="REDIS缓存"><a href="#REDIS缓存" class="headerlink" title="REDIS缓存"></a>REDIS缓存</h1><h2 id="Nosql概述"><a href="#Nosql概述" class="headerlink" title="Nosql概述"></a>Nosql概述</h2><p>NoSQL &#x3D; Not Only SQL (不仅仅是SQL)</p><p>泛指非关系型数据库的，随着web2.0 传统的关系型数据库 很难对付web2.0时代</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒写8万次。读取11万，NoSql的缓存记录级，是一种细粒度的缓存，性能会比较高）</p></li><li><p>数据类型的多样性（不需要事先设计数据库）</p></li><li><p>传统RDBMS和NoSQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中</span><br><span class="line">- 数据操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NoSQL</span><br><span class="line">不仅仅是数据</span><br><span class="line">没有固定的查语句</span><br><span class="line">键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">最终一致性</span><br><span class="line">CAP定理和BASE(异地多活) </span><br><span class="line">高性能 高可用 高扩展</span><br></pre></td></tr></table></figure></li></ol><h3 id="四大类型"><a href="#四大类型" class="headerlink" title="四大类型"></a>四大类型</h3><p>键值对存储 Redis</p><p>列存储 HBase</p><p>文档存储 MongoDB</p><p>图形数据库（社交关系）</p><h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><p>Remote Dictionary Server 远程字典服务</p><p>开源 C语言编写 支持网络 key-value</p><p>当下最热门的NoSQL技术</p><hr><ol><li>内存存储 持久化</li><li>效率高</li><li>发布订阅</li><li>地图信息</li><li>计时器</li></ol><hr><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h3><ol><li><p>下载地址：<a href="https://github.com/dmajkic/redis/releases">https://github.com/dmajkic/redis/releases</a></p></li><li><p>使用redis客户端</p></li><li><p>测试 开启服务端和客户端 在客户端测试</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set name xiadujian</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">&quot;xiadujian&quot;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装*"></a>Linux安装*</h3><ol><li>下载安装包</li><li></li></ol><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p><code>redis-benchmark -[命令]</code></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>默认有16个数据库 默认使用第0个数据库</p><h2 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h2><h3 id="Redis-Key"><a href="#Redis-Key" class="headerlink" title="Redis-Key"></a>Redis-Key</h3><p><code>select index</code>切换数据库</p><p><code>DBSIZE</code> 数据库长度</p><p><code>keys *</code>查看数据库所有key</p><p><code>flushdb</code>清空当前数据库</p><p><code>flushall</code>清楚全部数据库的内容</p><p><code>EXISTS key</code>判断某个键是否存在（存在返回1 不存在返回0）</p><p><code>MOVE key</code>移除某一个key</p><p><code>EXPIRE key time</code>设置某一个key  time秒后过期</p><p><code>ttl key</code>查看当前key的剩余时间</p><p><code>type name</code>查看当前key的一个类型</p><h3 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h3><p><code>APPEND key &quot;data&quot;</code>在key对应value字符串追加内容</p><p><code>incr key</code>某一个key数据自增1</p><p><code>incrby key i</code>  某一个key数据自增i</p><p><code>decr key</code>某一个key数据自减1</p><p><code>decrby key i</code>某一个key数据自减i</p><p><code>GETRANGE key 0 3</code>截取字符串[0,3]</p><p><code>GETRANGE key 0 -1</code>截取全部字符串</p><p><code>SETRANGE key 1</code>替换指定位置开始的字符串</p><p><code>setex key time value </code>设置过期时间</p><p><code>setnx key value</code>如果key不存在 创建成功，否则失败</p><p><code>mget k1 k2 k3</code>同时获取多个值</p><p><code>msetnx k1 v1 k2 v2</code>同时设置多个值（原子性操作，同时成功失败）</p><p><code>set user:1 &#123;name:xdj,age:3&#125;</code>设置一个对象</p><h3 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h3><p><code>LPUSH list value</code>在list左边插值</p><p><code>RPUSH list value</code>在list右边插值</p><p><code>LPOP list</code>移除列表第一个元素</p><p><code>RPOP list</code>移除列表最后一个元素</p><p><code>LRANGE LIST 0 -1</code>获取list数据 从左到右</p><p><code>RRANGE LIST 0 -1</code>获取list数据 从右到左</p><p><code>LREM list i value</code>移除list中指定i个value</p><p><code>ltrim list 1 2</code>通过下标截取指定下标间的内容</p><p><code>rpoplpush list list2</code>移除list中最后一个元素到list2中</p><h3 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h3><p><code>sadd list value</code>在set中存入一个值</p><p><code>SMEMBERS list</code>查看指定set中所有值</p><p><code>scard list</code>获取set集合中元素个数</p><p><code>srem list value</code>移除set集合中指定元素</p><p><code>SRANDMEMBER list</code>随机获取set中一个元素</p><p><code>SDIFF key1 key2</code> 差集</p><p><code>SINTER key1 key2</code>交集</p><p><code> SUNION key1 key2</code>并集</p><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><p>Map集合 key-map</p><p><code>hset hash field xiadujian</code>在hash中添加一个map key为field value为xiadujian</p><p><code>hget hash field</code>获取关键字field对应的map</p><p><code>hmset hash field xiadujian field1 xiatiantian</code>添加多个值</p><p><code>hmget hash field field1</code>获取多个值</p><p><code>hgetall hash</code>获取所有</p><p><code>hdel hash field</code>删除指定的key对应值</p><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><p><code>zadd set i value</code>添加一个值</p><p><code>zadd set 1 value1 2 value2</code>添加多个值</p><p><code>ZRANGEBYSCORE salary min max</code>排序 从最小值到最大值（-inf +inf 负无穷 正无穷）</p><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><h3 id="geospatial地理位置"><a href="#geospatial地理位置" class="headerlink" title="geospatial地理位置"></a>geospatial地理位置</h3><p><code>geoadd china:city [经度] [纬度] key</code>添加一个地理位置</p><p><code>geopos china:city key</code>获取指定超市的经度纬度</p><p><code>geodist china city key1 key2 [单位]</code>返回给定两个坐标距离 单位 km,m,mi(英尺),ft(英里)</p><p><code>georadius china:city [经度][纬度] value km withdist</code>查询半径value以内的所有坐标(withdist:返回形式位置+距离）</p><p><code>georadius china:city [经度][纬度] value km withcoord</code>查询半径value以内的所有坐标(withdist:返回形式位置+经纬度）</p><h3 id="Hyperloglog基数统计"><a href="#Hyperloglog基数统计" class="headerlink" title="Hyperloglog基数统计"></a>Hyperloglog基数统计</h3><p>优点相比于set计数所占内存极少</p><p><code>PFadd key value</code>添加</p><p><code>PFCOUNT key</code>计数</p><p><code>PFMERGE key3 key2 key1</code>12&#x3D;3合并</p><h3 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h3><p>位存储 一般用于状态 是否</p><p><code>setbit sign key value</code>添加</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务本质：一组命令的集合</p><p style="color:red">Redis单条命令保持原子性，但是事务不保证原子性</p><p>Redis事务没有隔离级别的概念 如脏读…</p><p>redis事务命令：</p><ul><li>开启事务（multi）</li><li>命令入队（所有需要执行的命令…）</li><li>执行事务（exec）</li><li>放弃事务（DISCARD）</li></ul><blockquote><p>监控：Watch</p></blockquote><p>watch 监视</p><p>unwatch 取消监视</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>是Redis官方推荐的java连接开发工具</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">System.out.println(jedis.ping());</span><br><span class="line"><span class="comment">//返回 PONG</span></span><br></pre></td></tr></table></figure><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>String</p><p>List</p><p>Set</p><p>Hash</p><p>Zset</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建json</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">jsonObject.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">jsonObject.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;xiadujian&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jsonObject.toJSONString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">multi.set(<span class="string">&quot;user1&quot;</span>,result);</span><br><span class="line">multi.set(<span class="string">&quot;user2&quot;</span>,result);</span><br><span class="line">multi.exec();<span class="comment">//执行事务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">multi.discard();<span class="comment">//放弃事务</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;flnally&#123;</span><br><span class="line">jedis.close();<span class="comment">//关闭连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h2><p>在SpringBoot2.X之后，原来使用的jedis被替换为了lettuce</p><p>jedis:采用的直连，多个线程操作不安全 使用jedis pool连接池</p><p>lettuce:采用netty,实例可以再多个线程中进行共享，不存在线程不安全</p><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#SpringBoot所有的配置类</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><h3 id="配置Config"><a href="#配置Config" class="headerlink" title="配置Config"></a>配置Config</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">RedisTemplate&lt;String,Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String,Object&gt;();</span><br><span class="line">template.setConnectionFactory(factory);</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjedctMapper(om);</span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerialize);</span><br><span class="line">        <span class="comment">//hash的key采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerialize);</span><br><span class="line">        <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        </span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redis工具类"><a href="#Redis工具类" class="headerlink" title="Redis工具类"></a>Redis工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hui.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// =============================common============================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">        redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForValue().set(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        set(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        expire(key, time);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        expire(key, time);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">    redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">        expire(key, time);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">        expire(key, time);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">      <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">        expire(key, time);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">      <span class="keyword">return</span> remove;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Redis-config配置"><a href="#Redis-config配置" class="headerlink" title="Redis config配置*"></a>Redis config配置*</h2><h2 id="持久化-RDB"><a href="#持久化-RDB" class="headerlink" title="持久化 RDB"></a>持久化 RDB</h2><p>（Redis DataBase）<strong>快照</strong> <strong>默认配置足以</strong> 在指定的时间间隔内将内存中的数据集快照写入磁盘 效率较高 保存的文件是dump.rdb</p><p><code>save ss number</code>在配置文件中设置ss秒内修改number个数据进行保存</p><p>通过添加子进程额外进行数据</p><p>优：适合大规模的数据恢复 对数据完整性要求不高</p><p>缺：fork进程的时候会占用一定的内容空间 需要一定的时间间隔进行操作，遇到redis意外宕机 当此修改就无效了</p><h2 id="持久化-AOF"><a href="#持久化-AOF" class="headerlink" title="持久化 AOF"></a>持久化 AOF</h2><p>（Append Only File）</p><p>以日志的方式记录每个写操作（除读取操作），只追加文件，但不能改写文件，redis启动时会读取该文件进行数据的重构</p><p>默认是不开启的，需要手动配置</p><p><code>appendonly no</code>在配置文件中修改appendonly  只需将no改为 yes</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认不开启AOF持久化 需要手动开启</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment">#持久化的文件的名字</span></span><br><span class="line"></span><br><span class="line">appendfsync always <span class="comment">#每次修改都会 sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment">#每秒执行一次 sync 可能会丢失1s的数据</span></span><br><span class="line">appendfsync no <span class="comment">#不执行 sync,这个时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure><p>优：每次修改同步，文件完整性好 只可能丢失1s的数据 从不同步效率最高</p><p>缺：相对于数据文件 AOF远大于RDB 修复速度慢 运行效率也较慢</p><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>消息通信模式</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#订阅 xxx 频道</span></span><br><span class="line">SUBSCRIBE xxx</span><br><span class="line"></span><br><span class="line"><span class="comment">#发布消息message到xxx频道</span></span><br><span class="line">PUBLISH xxx message </span><br></pre></td></tr></table></figure><ol><li>实时消息系统</li><li>实时聊天</li></ol><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制*"></a>主从复制*</h2><p>数据的复制是单向的，只能从主–&gt;从 读写分离 80%是读操作 一般是一主二从</p><p><strong>作用</strong>数据冗余 故障恢复 负载均衡 高可用</p>]]></content>
      
      
      <categories>
          
          <category> 技术支持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2022/10/06/technology/Linux/"/>
      <url>/2022/10/06/technology/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h1><p>是一套免费使用和自由传播的类Unix操作系统 以网络为核心的设计思想</p><p><strong>一切皆是文件</strong></p><p><strong>根目录 <code>/</code>：所有文件</strong></p><h2 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync</span> <span class="comment">#将数据由内存同步到硬盘中 在关机前操作</span></span><br><span class="line">shutdown <span class="comment">#关机指令</span></span><br><span class="line">shutdown -h 10 <span class="comment">#计算机将在十秒后关机</span></span><br><span class="line">shutdown -h now <span class="comment">#立刻关机</span></span><br><span class="line">shutdown -r now <span class="comment">#立刻重启</span></span><br><span class="line">shutdown -r +10 <span class="comment">#10分钟后重启</span></span><br><span class="line">reboot <span class="comment">#重启</span></span><br><span class="line">halt <span class="comment">#关闭系统</span></span><br></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><strong>&#x2F;bin</strong>存放最经常使用的命令</li><li><strong>&#x2F;boot</strong>    启动Linux的核心文件</li><li><strong>&#x2F;dev</strong>    存放Linux的外部设备</li><li><strong>&#x2F;etc</strong>    用来存放所有系统管理所需要的配置文件和子目录</li><li><strong>&#x2F;home</strong>    用户的主目录 一般该目录是以用户账号命名</li><li><strong>&#x2F;lib</strong>    存放系统最基本的动态连接共享库</li><li><strong>&#x2F;lost+found</strong>    当系统非法关机存放文件</li><li><strong>&#x2F;media</strong>    自动设备挂载</li><li><strong>&#x2F;mnt</strong>    用户临时挂载别的文件系统</li><li><strong>&#x2F;opt</strong>    给主机额外安装软件所摆放的目录</li><li><strong>&#x2F;proc</strong>    系统内存映射</li><li><strong>&#x2F;root</strong>    系统管理员</li><li><strong>&#x2F;sbin</strong>    系统管理程序</li><li><strong>&#x2F;srv</strong>    服务启动之后需要提取的数据</li><li><strong>&#x2F;sys</strong>    文件系统sysfs</li><li><strong>&#x2F;tmp</strong>    存放临时文件</li><li><strong>&#x2F;usr</strong>    应用程序和文件存放位置</li><li><strong>&#x2F;usr&#x2F;bin</strong>    系统用户使用的应用程序</li><li><strong>&#x2F;usr&#x2F;sbin</strong>    超级用户高级管理程序</li><li><strong>&#x2F;usr&#x2F;src</strong>    内核源代码默认放置位置</li><li><strong>&#x2F;var</strong>    存放不断扩充的东西</li><li><strong>&#x2F;run</strong>    临时文件系统，存储系统启动以来的信息，系统重启这个目录的文件应该删除</li></ul><h2 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h2><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#绝对路径 相对路径</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#列出目录</span></span><br><span class="line"><span class="built_in">ls</span> -a <span class="comment">#查看全部文件，包括隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -l <span class="comment">#列出所有文件包含文件属性和权限，无隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -al <span class="comment">#所有Linux命令可以组合使用 查询全部文件包含隐藏文件及文件属性权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> [路径] <span class="comment">#切换目录命令</span></span><br><span class="line">./ <span class="comment">#当前目录</span></span><br><span class="line"><span class="built_in">cd</span> .. <span class="comment">#返回上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ../user <span class="comment">#相对路径跳转</span></span><br><span class="line"><span class="built_in">cd</span> /home/xdj <span class="comment">#绝对路径跳转</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment">#回到当前用户目录</span></span><br><span class="line"><span class="built_in">pwd</span> <span class="comment">#显示当前所在目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> [文件夹] <span class="comment">#创建一个目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p [文件夹/文件夹/文件夹] <span class="comment">#创建递归多级目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rmdir</span> [文件夹] <span class="comment">#删除文件夹</span></span><br><span class="line"><span class="built_in">rmdir</span> -p [文件夹/文件夹/文件夹] <span class="comment">#删除递归多级目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> [文件名] [文件夹] <span class="comment">#复制文件到指定目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#rm(移除文件或者目录)</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="comment">#忽略不存在的文件，不会出现警告，强制删除</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="comment">#递归删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -i <span class="comment">#互动，删除询问是否删除</span></span><br><span class="line"><span class="built_in">rm</span> -rf / <span class="comment">#系统中所有文件删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mv 移动文件或目录</span></span><br><span class="line"><span class="built_in">mv</span> -f 强制</span><br><span class="line"><span class="built_in">mv</span> -u 只替换已经更新的文件</span><br></pre></td></tr></table></figure><p>文件搜索 find</p><p>挂载 mount</p><h1 id="Linux环境搭建"><a href="#Linux环境搭建" class="headerlink" title="Linux环境搭建"></a>Linux环境搭建</h1><h2 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">application</span>\<span class="title">WORK</span>\<span class="title">Linux</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术支持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins</title>
      <link href="/2022/10/06/technology/Jenkins/"/>
      <url>/2022/10/06/technology/Jenkins/</url>
      
        <content type="html"><![CDATA[<h1 id="Jenkins基础"><a href="#Jenkins基础" class="headerlink" title="Jenkins基础"></a>Jenkins基础</h1><h2 id="软件开发流程"><a href="#软件开发流程" class="headerlink" title="软件开发流程"></a>软件开发流程</h2><p>需求分析-&gt;项目设计-&gt;项目编码-&gt;测试-&gt;维护</p><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>简单易用理解 只需关注当前阶段</p><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><p>迭代 增量  早期交付 降低软件开发成本</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>（Continuous integration,简称CI）敏捷开发很大一部分归功于持续集成</p><p>自动化构建过程 代码仓库 持续集成服务器</p><blockquote><p>优点：降低风险 对系统健康检查 减少重复性工作 持续部署 持续交付可供使用的版本 增强团队信心</p></blockquote><h2 id="Jenkins简介"><a href="#Jenkins简介" class="headerlink" title="Jenkins简介"></a>Jenkins简介</h2><p>是一款流行的开源持续集成工具，广泛用于项目开发，具有自动化构建，测试，部署功能</p><ol><li>开源，基于java</li><li>易于安装部署</li><li>分布式构建</li><li>文件识别</li><li>丰富的插件支持</li></ol><h2 id="Jenkins安装环境配置"><a href="#Jenkins安装环境配置" class="headerlink" title="Jenkins安装环境配置"></a>Jenkins安装环境配置</h2><p><img src="D:\Data\Typora\资料库\图纸\持续集成流程图.png" alt="持续集成流程图"></p><h3 id="服务器软件安装列表"><a href="#服务器软件安装列表" class="headerlink" title="服务器软件安装列表"></a>服务器软件安装列表</h3><table><thead><tr><th>名称</th><th>IP地址</th><th>安装的软件</th></tr></thead><tbody><tr><td>代码托管服务器</td><td>-</td><td>Gitlab</td></tr><tr><td>持续集成服务器</td><td>-</td><td>jenkins,JDK,Maven,GIt,SonarQube</td></tr><tr><td>应用测试服务器</td><td>-</td><td>JDK1.8,Tomcat</td></tr></tbody></table><h2 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h2><h3 id="安装配置（略）"><a href="#安装配置（略）" class="headerlink" title="安装配置（略）"></a>安装配置（略）</h3><h3 id="分组-创建用户-创建项目"><a href="#分组-创建用户-创建项目" class="headerlink" title="分组 创建用户 创建项目"></a>分组 创建用户 创建项目</h3><p>GitLab用户在组中的五种权限：</p><ol><li>Guest：只能创建issue,发表评论，不能读写版本库</li><li>Reporter：可以克隆代码，不能提交，QA、PM可以赋予这个权限</li><li>Developer：可以克隆代码  开发 提交 push（适用普通开发人员）</li><li>Maintainer：可以创建项目 添加tag 保护分支 添加项目成员 编辑项目 （核心开发权限）</li><li>Owner：可以设置项目访问权限 删除项目 迁移项目 管理组成员 （开发组组长）</li></ol><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h3><p>汉化插件</p><p>Role-based Authorization Strategy(用户权限)</p><p>git插件</p><ol><li>HTTP: username password</li><li>SSH:在GitLab服务器存放公钥 在Jenkins服务器放私钥</li></ol><h3 id="一些配置"><a href="#一些配置" class="headerlink" title="一些配置"></a>一些配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/*安装Maven*/</span><br><span class="line">tar -xzf apache-maven-3.6.2-bin.tar.gz 解压</span><br><span class="line">mkdir -p /opt/maven 创建目录</span><br><span class="line">mv apache-maven-3.6.2/*/opt/maven 移动文件</span><br><span class="line"></span><br><span class="line">/*配置环境变量*/</span><br><span class="line">export JAVA_HOME = /use/lib/jvm/language-1.8.0-openjdk</span><br><span class="line">export MAVEN_HOME = /opt/maven</span><br><span class="line">export PATH = $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>在Jenkins全局配置（Clobal Tool Configuration）中配置JKD和Maven路径</p><p>在Jenkins系统配置（Configure System）加入一些变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">java地址</span><br><span class="line"></span><br><span class="line">M2_HOME</span><br><span class="line">Maven地址</span><br><span class="line"></span><br><span class="line">PATH+EXTRA</span><br><span class="line">$M2_HOME/bin</span><br></pre></td></tr></table></figure><p>修改Maven的setting.xml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir/root/repo 创建本地仓库</span><br><span class="line">vi/opt/maven/conf/settings.xml</span><br><span class="line">本地仓库改为：&lt;localRepository&gt;/root/repo/&lt;/localRepository&gt;</span><br><span class="line"></span><br><span class="line">添加阿里云私服地址：</span><br><span class="line">&lt;mirror&gt;</span><br><span class="line">&lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">&lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">&lt;mirrorof&gt;central&lt;/mirrorof&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure><h3 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h3><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*添加并解压*/</span><br><span class="line">tar -xzf apache-tomcat-8.5.47.tat.gz</span><br><span class="line">/*创建目录 移动tomcat解压文件*/</span><br><span class="line">mkdir /opt/tomcat</span><br><span class="line">mv apache-tomcat-8.5.47/* /opt/tomcat</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置文件在 conf&#x2F;tomcat-users.xml</p><p><code>vi tomcat-users.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;tomcat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;role1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-status&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;tomcat&quot;</span> <span class="attr">password</span>=<span class="string">&quot;tomcat&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;manager-gui,manager-script,tomcat,admin-gui,admin-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了能够用刚配置的用户登录到Tomcat，需要修改以下配置</p><p>vi&#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;manager&#x2F;META-INF&#x2F;context.xml</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--&lt;value className=&quot;org.apache.catolina.values.RemoteAddrValue&quot; allow=&quot;127\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; --&gt;</span><br></pre></td></tr></table></figure><h1 id="Jenkins构建"><a href="#Jenkins构建" class="headerlink" title="Jenkins构建"></a>Jenkins构建</h1><h2 id="项目构建类型"><a href="#项目构建类型" class="headerlink" title="项目构建类型"></a>项目构建类型</h2><ul><li>自由风格软件项目（FreeStyle Project）默认</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.git 拉取代码</span><br><span class="line">2.编译打包 添加构建步骤 一般情况下用shell脚本</span><br><span class="line">/--测试 模拟</span><br><span class="line">echo &quot;开始编译和打包&quot;</span><br><span class="line">mvn clean package</span><br><span class="line">echo &quot;编译和打包结束&quot;</span><br><span class="line">--/</span><br><span class="line">3.上传部署 改建后操作</span><br><span class="line">/--</span><br><span class="line">WAR/EAR file : target/*.war</span><br><span class="line">Context path</span><br><span class="line">Containers 选择合适的Tomcat服务器版本</span><br><span class="line">Credentials 认证 tomcat账号密码</span><br><span class="line">Tomcat URL Tomcat远程地址</span><br><span class="line">--/</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Maven项目（Maven Project）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.安装插件 Maven Integration</span><br></pre></td></tr></table></figure><ul><li>流水线项目（Pipeline Project）</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>将项目部署到远程Tomcat服务器</p><p>1）安装Deploy to container插件</p><p>Jenkins本身无法实现远程部署到Tomcat的功能。</p>]]></content>
      
      
      <categories>
          
          <category> 技术支持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2022/10/06/technology/Git/"/>
      <url>/2022/10/06/technology/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><hr><p>​版本迭代需要一个<strong>版本控制</strong>（Revision control）在开发中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术</p><ol><li><p>实现跨区域多人协同开发</p></li><li><p>追踪和记载一个或多个文件的历史记录</p></li><li><p>组织保护你的源代码和文档</p></li><li><p>统计工作量</p></li><li><p>并行开发、提高开发效率</p></li><li><p>跟踪记录整个软件的开发过程</p></li><li><p>减轻开发人员的负担，节省时间，同时降低人为错误</p><h2 id="第一次配置github与使用https-www-cnblogs-com-sdcs-p-8270029-html"><a href="#第一次配置github与使用https-www-cnblogs-com-sdcs-p-8270029-html" class="headerlink" title="第一次配置github与使用https://www.cnblogs.com/sdcs/p/8270029.html"></a>第一次配置github与使用<a href="https://www.cnblogs.com/sdcs/p/8270029.html">https://www.cnblogs.com/sdcs/p/8270029.html</a></h2></li></ol><hr><p>[TOC]</p><hr><h4 id="一、常见主流版本控制器"><a href="#一、常见主流版本控制器" class="headerlink" title="一、常见主流版本控制器"></a>一、常见主流版本控制器</h4><ol><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li>TFS</li><li>Visual Studio Online</li></ol><h4 id="二、版本控制分类"><a href="#二、版本控制分类" class="headerlink" title="二、版本控制分类"></a>二、版本控制分类</h4><ol><li>本地版本控制：记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合<strong>个人</strong>，如RCS</li><li>集中式版本控制：所有版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改，适合<strong>多人</strong>，如SVN</li><li>分布式版本控制：每个人都拥有全部的代码，具有安全隐患。在本地就可以看到所有代码，不会因为服务器损坏，网络问题导致不能工作的情况。适合<strong>多人</strong>，如Git</li><li>Git与SVN区别<ul><li>Git:每个电脑就是完整的服务器，不需要联网，Git可以直接看到更新的代码</li><li>SVN:版本放在中央服务器，需要联网使用，从服务器获取，操作完再提交到服务器</li></ul></li></ol><p><strong>Git是目前世界上最先进的分布式版本控制系统</strong></p><h4 id="三、安装卸载"><a href="#三、安装卸载" class="headerlink" title="三、安装卸载"></a>三、安装卸载</h4><ol><li>安装地址<a href="http://npm.taobao.org/mirrors/git-for-windows/v2.32.0.windows.2/">git-for-windows Mirror (taobao.org)</a></li><li>无脑安装</li><li>卸载 删除git的环境变量 打开控制面板卸载</li></ol><p>安装完成后，菜单下有三个Git项，任意文件夹下右键也可以看到对应的程序</p><ul><li>Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多 （清屏clear）</li><li>Git CMD：Windows风格的命令行（清屏cls）</li><li>Git GUI：图形界面的Git,不建议初学者使用，尽量县属虚常用命令</li></ul><h4 id="四、基本Linux命令"><a href="#四、基本Linux命令" class="headerlink" title="四、基本Linux命令"></a>四、基本Linux命令</h4><ol><li><p>cd：改变目录</p></li><li><p>cd ..：回退到上一个目录，直接cd进入默认目录</p></li><li><p>pwd：显示当前所在目录路径</p></li><li><p>ls(II)：都是列出当前目录中的所有文件，只不过II（两个II）列出的内容更为详细</p></li><li><p>touch：新建一个文件 如touch index.js 就会在当前目录下新建一个index.js文件</p></li><li><p>rm：删除一个文件，rm index.js 就是把index.js文件删除</p></li><li><p>mkdir：新建一个目录。就是新建一个文件夹</p></li><li><p>rm -r：删除一个目录。就是删除一个文件夹</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#格式化电脑 删除电脑中全部文件</span><br><span class="line">rm -rf/</span><br></pre></td></tr></table></figure></li><li><p>mv：移动文件，mv index.html src index.html是我们要移动的文件。src是目标文件夹</p></li><li><p>reset：重新初始化终端。清屏</p></li><li><p>clear：清屏</p></li><li><p>history：查看命令历史</p></li><li><p>help：帮助</p></li><li><p>exit：退出</p></li><li><p>#：表示注释</p></li></ol><p>五、Git的必要配置</p><ol><li><p>得到Git当前所有配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure></li><li><p>只看系统的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure></li><li><p>只看本地的配置，即自己的配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br><span class="line">#设置邮箱与用户</span><br><span class="line">git config --global user.name &quot;xdj&quot;</span><br><span class="line">git config --global user.email &quot;1226954639@qq.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>Git相关配置文件位置</p><ul><li><p>系统Git\etc\gitconfig ：Git安装目录下的gitconfig  –system系统级</p></li><li><p>用户    C:\Users\lenovo.gitconfig 只适用于当前登录用户的配置 –global全局</p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里</p></li></ul></li></ol><h4 id="五、Git基本理论（核心）"><a href="#五、Git基本理论（核心）" class="headerlink" title="五、Git基本理论（核心）"></a>五、Git基本理论（核心）</h4><p><img src="D:\Data\Typora\资料库\图纸\Git原理_01.png"></p><ol><li>Workspace：工作区，平时放代码的地方</li><li>Index&#x2F;Stage：暂存区，用于临时存放你的改动，事实上只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版权的数据，其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台用于远程数据交换</li></ol><h4 id="六、Git项目创建"><a href="#六、Git项目创建" class="headerlink" title="六、Git项目创建"></a>六、Git项目创建</h4><ol><li>初始化本地本地  git init</li><li>初始化远程仓库  git clone [url]</li><li>查看指定文件状态   git status [filename]</li><li>查看所有文件状态   git status</li><li>添加所有文件到暂存区   git add .</li><li>提交暂存区中的内容到   git commit -m</li></ol><h4 id="七、Git基本操作命令"><a href="#七、Git基本操作命令" class="headerlink" title="七、Git基本操作命令"></a>七、Git基本操作命令</h4><ol><li><p>有时候不想把一些文件纳入版本控制器中，比如数据库文件，临时文件，设计文件。在主目录下创建.gitignore文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该文件有以下语法规则 #为注解</span><br><span class="line">*.txt#忽略所有 .txt结尾的文件</span><br><span class="line">！lib.txt    #lib.txt除外</span><br><span class="line">/temp        #仅忽略项目根目录下的TODO文件，不包括其他目录temp</span><br><span class="line">build/       #忽略build/目录下的所有文件</span><br><span class="line">doc/*.tex    #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure></li></ol><h4 id="八、码云的注册和使用"><a href="#八、码云的注册和使用" class="headerlink" title="八、码云的注册和使用"></a>八、码云的注册和使用</h4><ol><li><p>设置本机绑定SSH公钥，实现免密码登录</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入 C：\Users\lenovo\.ssh目录</span><br><span class="line">#生成公钥 加密算法</span><br><span class="line">ssh-keygen [-t rsa]</span><br></pre></td></tr></table></figure></li><li><p>将公钥信息public key 添加到码云账户中</p></li><li><p>使用码云创建一个自己的仓库</p></li><li><p>将.ssh中的公钥id_rsa.pub中的内容复制到码云的SSH公钥中</p></li><li><p>新建仓库</p></li><li><p>克隆  复制http路径</p></li><li><p>命令行下载到本地</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/xdjclover/gitstudy.git</span><br></pre></td></tr></table></figure></li></ol><h4 id="九、idea集成git"><a href="#九、idea集成git" class="headerlink" title="九、idea集成git"></a>九、idea集成git</h4><ol><li><p>新建idea项目</p><ul><li>将我们远程的git文件目录拷贝到项目中即可</li></ul></li><li><p>修改文件，使用idea操作git</p><ul><li>git add .       添加到暂存区</li><li>git commit -m “修改内容”       提交</li><li>git push 到远程仓库</li><li></li></ul></li><li><p>提交测试</p></li><li><p>分支    master主分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列出所有分支</span><br><span class="line">git branch</span><br><span class="line">#列出所有远程分支</span><br><span class="line">git branch -r</span><br><span class="line">#新建一个分支，但依然停留在当前分支</span><br><span class="line">git branch [branch-name]</span><br><span class="line">#新建一个分支，并切换到该分支</span><br><span class="line">git checkout -b [branch]</span><br><span class="line">#合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line">#删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line">#删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remotr/branch]</span><br><span class="line">#回到主支上 main为主支</span><br><span class="line">$ git rebase main</span><br><span class="line">#^当前指向bugFix的父支点，~4向上4支点</span><br><span class="line">$ git checkout bugFix^</span><br><span class="line">$ git checkout bugFix~4</span><br><span class="line">#将main提交放置在c6结点上</span><br><span class="line">$ git branch -f main c1</span><br><span class="line">#撤销有两种，reset 撤销返回到上一层适合本地    revert再次提交，将上次修改的恢复适合远程</span><br><span class="line">$ git reset head^</span><br><span class="line">$ git revert head</span><br><span class="line">#将c2提交放到当前所在的位置下面</span><br><span class="line">$ git cherry-pick c2</span><br><span class="line">#rebase 将选择支点放到d点后  rebase -i 放从main回头四个支点放到指定点后</span><br><span class="line">$ git rebase main</span><br><span class="line">$ git rebase -i main~4</span><br></pre></td></tr></table></figure><p>如果多个分支并行执行，就会导致我们代码不冲突，也就是同时存在多个版本</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术支持 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2022/10/06/language/JAVA%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/10/06/language/JAVA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h2 id="面向对象-对象"><a href="#面向对象-对象" class="headerlink" title="面向对象-对象"></a>面向对象-对象</h2><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h1 id="进阶部分"><a href="#进阶部分" class="headerlink" title="进阶部分"></a>进阶部分</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final修饰的类无法继承（最终类）</p><p>final修饰的方法无法覆盖</p><p>final修饰的变量只能赋值一次</p><p>final修饰的引用一旦指向某个对象，则不能再重新指向其他对象，但该指向对象实例的属性可用修改</p><p>final修饰的实例变量必须手动赋初值，不能采用系统默认</p><p>final修饰的实例变量一般和static联合使用，称为&#x3D;&#x3D;<strong>常量</strong>&#x3D;&#x3D;</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>定义：在class前添加abstract</p><p>抽象类属于引用类型，无法实例化对象，只能被继承</p><p>final和abstract不能联合使用，这两个关键字是对立的</p><p>抽象类的子类可用是抽象类，也可以是非抽象类</p><p>抽象类可以有构造方法，可以供子类使用</p><p>抽象类中不一定有抽象方法，抽象方法一定出现在抽象类中</p><p>抽象方法的定义：public abstract void add();</p><p>非抽象类继承抽象类必须将抽象类中的抽象方法进行覆盖&#x2F;重写&#x2F;实现</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>定义：interface</p><p>接口也是一种引用数据类型，编译以后也是一个class字节码文件</p><p>接口是完全抽象的（抽象类是半抽象的）</p><p>接口支持多继承，一个接口可以继承多个接口</p><p>接口中只包含两种内容：常量；抽象方法</p><p>接口所有元素都是public修饰的</p><p>接口中的方法定义：public abstract void add(); abstract可以省略</p><p>接口中的常量定义：public static final String NAME;</p><p>非抽象的类实现接口，必须实现接口中所有方法实现</p><p>一个类可以实现多个接口</p><p>extends和implements可以同时使用，extends在前，implements在后</p><p>使用接口，写代码时可以使用多态，父类引用变量指向子类实例对象</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>接口在开发中作用类似多态：面向对象，降低耦合，提高程序扩展能力</p><h3 id="抽象类和接口区别"><a href="#抽象类和接口区别" class="headerlink" title="抽象类和接口区别"></a>抽象类和接口区别</h3><p>抽象类是半抽象的</p><p>接口是完全抽象的</p><p>抽象类有构造方法</p><p>接口没有构造方法</p><p>接口和接口之间多继承</p><p>类和类之间单继承</p><p>一个类可以实现多个接口</p><p>一个类只能继承一个类</p><h2 id="Package和import"><a href="#Package和import" class="headerlink" title="Package和import"></a>Package和import</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p>package出现在Java源文件第一行</p><p>编译带有包名的类：javac -d . xxx.java</p><p>运行：java 完整类名</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 完整类名；</p><p>import 包名.*;</p><h2 id="JDK类库的根类：Object类"><a href="#JDK类库的根类：Object类" class="headerlink" title="JDK类库的根类：Object类"></a>JDK类库的根类：Object类</h2><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用程序编程接口</p><p>整个JDK的类库就是一个javase的API</p><p>每一个API都会配置一套API帮助文档</p><p>SUN公司提前写好的这套类库就是API。(一般每一份API都对应一份API帮助文档)</p><h3 id="Object中重点方法"><a href="#Object中重点方法" class="headerlink" title="Object中重点方法"></a>Object中重点方法</h3><p>protected Object clone()对象克隆</p><p>int hashCode()获取对象hash值</p><p>boolean equals(Object obj)判断两个对象是否相等</p><blockquote><p>一般我们使用的equals方法需要重写，因为默认该方法是比较对象的存储地址，我们一般用于比较内容</p><p>基本数据类型比较： &#x3D;&#x3D;</p><p>对象和对象比较：调用equals方法</p><p>String类是SUN公司写的，其equals方法已重写</p></blockquote><p>String toString()将对象转换为字符串形式</p><blockquote><p>默认是返回 getClass().getName() + “@” + Integer.toHexString(hashCode())</p><p>该方法一般使用都需要重写</p><p>String类是SUN公司写的，其toString方法已重写</p></blockquote><p>protected void finalize()垃圾回收器负责调用的方法</p><h2 id="常用八大类"><a href="#常用八大类" class="headerlink" title="常用八大类"></a>常用八大类</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol><li>字符串一旦创建不可改变</li><li>双引号括起来的字符串存储在字符串常量池中</li><li>字符串比较必须用equeal</li><li>String已经重写了toString和equeal方法</li></ol><h4 id="常用构造方法"><a href="#常用构造方法" class="headerlink" title="常用构造方法"></a>常用构造方法</h4><h4 id="String类常用的21个方法"><a href="#String类常用的21个方法" class="headerlink" title="String类常用的21个方法"></a>String类常用的21个方法</h4><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><ol><li>StringBuffer&#x2F;StringBuilder可看成可变长度的字符串</li><li>StringBuffer&#x2F;StringBuilder初始化容量是16</li><li>StringBuffer&#x2F;StringBuilder完成字符串拼接操作，方法名append</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的</li><li>频繁进行字符串拼接不建议使用”+”</li></ol><h3 id="基础类型对应的8个包装类"><a href="#基础类型对应的8个包装类" class="headerlink" title="基础类型对应的8个包装类"></a>基础类型对应的8个包装类</h3><p>包装类存在的意义：方便编程。java中有8个基本数据类型，为了适应面向对象的编程，所以封装了8个包装类对应八个基本数据类型</p><table><thead><tr><th>基本类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>byte</td><td>Byte</td></tr></tbody></table><p>所有数字的父类&#x3D;&#x3D;<strong>Number</strong>&#x3D;&#x3D;</p><p>自动装箱和自动拆箱：装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">System.out.println(x==y);<span class="comment">//true</span></span><br><span class="line"><span class="comment">//因为超出了Integer的范围，所以变成了基本类型</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(m==n);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h3><ol><li><p>获取当前日期：Date date &#x3D; new Date();</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date date = new Date();</span><br></pre></td></tr></table></figure></li><li><p>日期格式化：Date ——&gt; String</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</span><br><span class="line">String s = simpleDateFormat.format(date);</span><br></pre></td></tr></table></figure></li><li><p>字符串转日期：String —&gt; Date</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date date1 = simpleDateFormat.parse(&quot;2021-08-23 05:20:20&quot;);</span><br></pre></td></tr></table></figure></li><li><p>获取毫秒数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long begin = System.currentTimeMillis();</span><br></pre></td></tr></table></figure></li></ol><h3 id="数字相关类"><a href="#数字相关类" class="headerlink" title="数字相关类"></a>数字相关类</h3><p>数字格式化：DecimalFormat</p><p>价格等金钱浮点数格式：BigDecimal</p><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>产生一个随机数（0~1]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random random = new Random();</span><br><span class="line">int i = random.nextInt();</span><br></pre></td></tr></table></figure><p>产生一定范围内的随机数（0~100]</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int ii = random.nextInt(101);</span><br></pre></td></tr></table></figure><h3 id="Enum枚举"><a href="#Enum枚举" class="headerlink" title="Enum枚举"></a>Enum枚举</h3><ol><li><p>枚举是一种引用数据类型</p></li><li><p>枚举编译后也是class文件</p></li><li><p>枚举的定义</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum enums&#123;</span><br><span class="line">    num,num1,num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个方法返回结果超过两种情况，并且是可以一枚一枚列举出来的时候，建议返回值类型设计为枚举类型</p></li></ol><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>增强程序健壮性，异常以对象形式存在</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解（Annotation）也被称为元数据（Metadata），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息</p><p>和注释一样，不影响程序逻辑性，但注解可以被编译或运行，相当于嵌入在代码中的补充信息</p><p>在JAVA SE中注解使用较为简单，在JAVA EE中注解占据根重要的角色，配置应用程序的任何切面，代替繁冗代码和XML配置</p><h3 id="三个基本注解"><a href="#三个基本注解" class="headerlink" title="三个基本注解"></a>三个基本注解</h3><p>@Override:限定某一个方法，是重写父类或接口方法，该注解只能用于方法</p><p>@Deprecated:用于表示某个程序元素（类，方法）已过时</p><p>@SuppressWarnings:抑制编译器警告</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>JDK的元Annotation用于修饰其他Annotation</p><ol><li>Retention：指定注解作用范围，三种（SOUREC,CLASS,RUNTIME）</li><li>Target：指定注解可以在哪些地方使用</li><li>Documented：指定注解是否会在javadoc体现</li><li>Inherited：子类会继承父类注解</li></ol><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>可以动态的保存任意多个元素，使用方便</p><p>提供一系列方便的操作对象的方法：add,remove,set,get等</p><p>使用集合添加，删除元素的示意代码-简洁</p><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>常用方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new ArrayList();</span><br><span class="line">//  add:添加单个元素</span><br><span class="line">list.add(&quot;夏兮&quot;);</span><br><span class="line">//  remove:删除指定元素</span><br><span class="line">list.remove(&quot;夏兮&quot;);</span><br><span class="line">list.remove(0);</span><br><span class="line">//  contains:查找元素是否存在</span><br><span class="line">list.contains(&quot;夏兮&quot;);</span><br><span class="line">//  size:获取元素个数</span><br><span class="line">list.size();</span><br><span class="line">//  isEmpty:判断是否为空</span><br><span class="line">list.isEmpty();</span><br><span class="line">//  clear:清空</span><br><span class="line">list.clear();</span><br><span class="line">//  addAll:添加多个元素</span><br><span class="line">list.addAll(new ArrayList());</span><br><span class="line">list.addAll(1,new ArrayList());</span><br><span class="line">//  containsAll:查找多个元素是否都存在</span><br><span class="line">list.containsAll(new ArrayList&lt;&gt;());</span><br><span class="line">//  removeAll:删除多个元素</span><br><span class="line">list.removeAll(new ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.单例集合：只有单个元素</span><br><span class="line">Collection接口有两个重要的子接口 List Set,他们的实现子类都是单例集合</span><br></pre></td></tr></table></figure><p><img src="D:\Data\Typora\资料库\图纸\Collection.png"></p><hr><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.双例集合：以键值对方式存储</span><br><span class="line">Map接口的实现子类 是双例集合，存放K-V</span><br></pre></td></tr></table></figure><p><img src="D:\Data\Typora\资料库\图纸\Map.png"></p><h3 id="迭代器Iterator"><a href="#迭代器Iterator" class="headerlink" title="迭代器Iterator"></a>迭代器Iterator</h3><p>collection继承于Iterator，所以collection的所有子类都有Iterator的iterator()方法,用以返回一个实现 了Iterator接口的对象，即返回一个迭代器，该对象仅用于&#x3D;&#x3D;<strong>迭代遍历集合</strong>&#x3D;&#x3D;，本身不存放对象。</p><p>增强for：底层依旧是迭代器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(Object s : list)&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>底层是一个数组： protected Object[] elementData</p><p>无参构造器 0—-&gt;10—-&gt;每次扩展1.5倍</p><p>有参构造器1.5倍扩容</p><p>线程不安全，效率高</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>底层是一个数组： protected Object[] elementData</p><p>线程安全，效率不高</p><p>无参 默认是10 2倍扩容</p><p>有参 2倍扩容</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>并发：一个CPU处理多个进程</p><p>并行：一个CPU处理一个进程</p><p>单线程：同一个时刻只允许执行一个线程</p><p>多线程：同一个时刻可以执行多个线程</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p>继承Thread创建线程</p><h3 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h3><p>实现Runnable接口添加run方法</p><p>多个子线程；通知线程退出，线程中断，线程插队，守护线程</p><h3 id="七种线程状态"><a href="#七种线程状态" class="headerlink" title="七种线程状态"></a>七种线程状态</h3><p><img src="D:\Data\Typora\资料库\图纸\线程状态生命周期.png"></p><h3 id="同步机制：synchronized"><a href="#同步机制：synchronized" class="headerlink" title="同步机制：synchronized"></a>同步机制：synchronized</h3><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p>互相占用了对方所需要的资源，导致线程死锁</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Serializable:串行化</p><p>Comparable:可以比较</p><p><img src="D:\Data\Typora\资料库\图纸\File.png" alt="File"></p><h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一: new File(String pathname)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\news1.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二: new File(File parent,String child) 根据父目录+文件名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\tmp&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile,fileName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三: new File(String parent,String child) 根据父目录+子路径来构建</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;D:\\&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentPath,filePath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件创建成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取文件信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//先创建文件对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\tmp\\news1.txt&quot;</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件常用方法</span></span><br><span class="line"><span class="comment">     * getName</span></span><br><span class="line"><span class="comment">     * getAbsolutePath</span></span><br><span class="line"><span class="comment">     * getParent</span></span><br><span class="line"><span class="comment">     * length</span></span><br><span class="line"><span class="comment">     * exists</span></span><br><span class="line"><span class="comment">     * isFile</span></span><br><span class="line"><span class="comment">     * isDirectory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//调用相应的方法，得到对应信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件名字=&quot;</span>+file.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件绝对路径=&quot;</span>+file.getAbsolutePath());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件父目录=&quot;</span>+file.getParent());</span><br><span class="line">    System.out.println(<span class="string">&quot;文件大小（字节）=&quot;</span>+file.length());<span class="comment">//11</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件是否存在=&quot;</span>+file.exists());<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个文件=&quot;</span>+file.isFile());<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是不是一个目录=&quot;</span>+file.isDirectory());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断 D:\\tmp\\news1.txt 文件是否存在</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\tmp\\news1.txt&quot;</span>;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">    <span class="keyword">if</span> (file.exists())&#123;</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        file.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不存在则新建</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;新建成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断 D:\\tmp 目录是否存在 原理与文件相同</span></span><br></pre></td></tr></table></figure><h3 id="IO流原理及流的分类"><a href="#IO流原理及流的分类" class="headerlink" title="IO流原理及流的分类"></a>IO流原理及流的分类</h3><p>IO是Input&#x2F;Output的缩写，用于数据传输，读写文件，网络通讯等</p><h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ol><li>按操作数据单位不同分：<ul><li>字节流（8 bit）：操作<strong>二进制文件</strong>保证无损操作</li><li>字符流（字符，因文件编码格式不同，长度不同）：操作<strong>文本文件</strong>效率一般较高</li></ul></li><li>按数据流的流向不同分：输入流，输出流</li><li>按流的角色不同分：节点流，处理流&#x2F;包装流</li></ol><table><thead><tr><th align="center">（抽象基类）</th><th align="center">字节流</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">输入流</td><td align="center">InputStream</td><td align="center">Reader</td></tr><tr><td align="center">输出流</td><td align="center">OutputStream</td><td align="center">Writer</td></tr></tbody></table><p><strong>JAVA的IO流共涉及40多个类，实际上非常规则，都是从如上&#x3D;&#x3D;4个抽象基类&#x3D;&#x3D;派生的，由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</strong></p><p><img src="D:\Data\Typora\资料库\图纸\IO流.jpg"></p><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><p><img src="D:\Data\Typora\资料库\图纸\InputStream.png"></p><ol><li><p>FileInputStream:文件输入流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示读取文件 --不能读取中文</span></span><br><span class="line"><span class="comment"> * 单个字节的读取，效率较低</span></span><br><span class="line"><span class="comment"> * ---&gt;改进使用 read(bete[] b) : read02()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建FileInputStream对象用于读取文件</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read():从文件中读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">        <span class="comment">//当返回-1时，表示读取完毕</span></span><br><span class="line">        <span class="keyword">while</span> ((readData = fileInputStream.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) readData);<span class="comment">//返回的是int，要转为char</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流，释放资源，防止资源浪费和内存泄漏</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//定义一个字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>]; <span class="comment">// 一次读取八个字节</span></span><br><span class="line">    <span class="comment">//实际读取字节个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建FileInputStream对象用于读取文件</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read():从文件中读取一个字节的数据，如果没有输入可用，此方法将阻止</span></span><br><span class="line">        <span class="comment">//当返回-1时，表示读取完毕</span></span><br><span class="line">        <span class="comment">//入关读取正常，返回实际读取个数</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen = fileInputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));<span class="comment">//返回的是int，要转为char</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭文件流，释放资源，防止资源浪费和内存泄漏</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedInputStream:缓冲字节输入流</p></li><li><p>ObjectInputStream:对象字节输入流 (反序列化)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反序列化后指定文件的内容</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\data.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line"><span class="comment">//读取</span></span><br><span class="line"><span class="comment">//1.读取（反序列化）的顺序要和保存数据（序列化）的顺序一致</span></span><br><span class="line">System.out.println(objectInputStream.readInt());</span><br><span class="line">System.out.println(objectInputStream.readBoolean());</span><br><span class="line">System.out.println(objectInputStream.readChar());</span><br><span class="line">System.out.println(objectInputStream.readDouble());</span><br><span class="line">System.out.println(objectInputStream.readUTF());</span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) objectInputStream.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;运行类型=&quot;</span>+dog.getClass());</span><br><span class="line">System.out.println(dog);</span><br><span class="line"></span><br><span class="line">objectInputStream.close();</span><br></pre></td></tr></table></figure></li></ol><h4 id="Outputstream"><a href="#Outputstream" class="headerlink" title="Outputstream"></a>Outputstream</h4><ol><li><p>FileOutputStream</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示使用FileOutputStream 将数据写入到文件中</span></span><br><span class="line"><span class="comment"> * 如果该文件不存在，则创建该文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建 FileOutputStream 对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\test.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到一个输出对象 FileOutputStream</span></span><br><span class="line">        <span class="comment">//1.new FileOutputStream(filePath)创建方式会覆盖文件原先内容</span></span><br><span class="line">        <span class="comment">//2.new FileOutputStream(filePath，true)创建方式，追加内容，不会覆盖原先内容</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//写入一个字节</span></span><br><span class="line">        <span class="comment">//fileOutputStream.write(&#x27;h&#x27;);</span></span><br><span class="line">        <span class="comment">//写入字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span>   <span class="operator">=</span> <span class="string">&quot;\nhello world,王富贵！&quot;</span>;</span><br><span class="line">        fileOutputStream.write(str.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文件拷贝</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完成文件拷贝，将 D:\\xdj.jpg 拷贝到 D:\\tmp\\</span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> * 1.创建文件的输入流，将文件读入到程序</span></span><br><span class="line"><span class="comment"> * 2.创建文件的输出流，将读取到的文件输出到指定位置</span></span><br><span class="line"><span class="comment"> * 注：利用循环，避免文件过大占用大量内存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件当前位置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\xdj.jpg&quot;</span>;</span><br><span class="line"><span class="comment">//文件复制目录</span></span><br><span class="line"><span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\tmp\\xdj.jpg&quot;</span>;</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    inputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">    outputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((readLen = inputStream.read(buf))!= -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//读取到后写入文件 边读边写</span></span><br><span class="line">        outputStream.write(buf,<span class="number">0</span>,readLen);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;拷贝成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (outputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">            outputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ObjectOutputStream:(序列化)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化后保存的文件格式不是纯文本，而是按照它的格式来保存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\data.dat&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化数据到文件：&quot;D:\\data.dat&quot;</span></span><br><span class="line">objectOutputStream.write(<span class="number">100</span>); <span class="comment">//int--&gt;Integer (实现了 Serializable)</span></span><br><span class="line">objectOutputStream.writeBoolean(<span class="literal">true</span>); <span class="comment">//boolean --&gt; Boolean (实现了Serializable)</span></span><br><span class="line">objectOutputStream.writeChar(<span class="string">&#x27;x&#x27;</span>);<span class="comment">//char --&gt; Character (实现了 Serializable)</span></span><br><span class="line">objectOutputStream.writeDouble(<span class="number">2.5</span>);<span class="comment">//double --&gt; Double (实现了 Serializable)</span></span><br><span class="line">objectOutputStream.writeUTF(<span class="string">&quot;夏杜键万岁！&quot;</span>);<span class="comment">//String</span></span><br><span class="line"><span class="comment">//保存一个对象</span></span><br><span class="line">objectOutputStream.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;二哈&quot;</span>,<span class="number">3</span>));</span><br><span class="line">objectOutputStream.close();</span><br></pre></td></tr></table></figure></li></ol><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><ol><li><p>FileReader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单个字符读取文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//1.创建FileReader对象</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((c=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>) c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileReader != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多个字符读取文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="comment">//1.创建FileReader对象</span></span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] buf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath);</span><br><span class="line">        <span class="comment">//循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((readLen=fileReader.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf,<span class="number">0</span>,readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileReader != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>BufferedReader</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\test.txt&quot;</span>;</span><br><span class="line"><span class="comment">//创建bufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(path));</span><br><span class="line">    <span class="comment">//bufferedReader.readLine() 按行读取</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//只需要关闭外层处理流</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><ol><li><p>FileWriter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\note.txt&quot;</span>;</span><br><span class="line"><span class="comment">//创建FileWriter对象</span></span><br><span class="line"><span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">char</span>[] c = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fileWriter  = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath,<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//写入单个字符</span></span><br><span class="line">    fileWriter.write(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="comment">//写入指定字符数组</span></span><br><span class="line">    fileWriter.write(c);</span><br><span class="line">    <span class="comment">//写入指定字符数组的指定部分</span></span><br><span class="line">    fileWriter.write(<span class="string">&quot;我是谁&quot;</span>.toCharArray(),<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//写入整个字符串</span></span><br><span class="line">    fileWriter.write(<span class="string">&quot;你好，臭屁虫&quot;</span>);</span><br><span class="line">    <span class="comment">//指定字符串某一个部分写入</span></span><br><span class="line">    fileWriter.write(<span class="string">&quot;杀死小朋友&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//对应FileWriter,一定要关闭流，或者flush才能把数据真正写入文件</span></span><br><span class="line">    <span class="keyword">if</span>(fileWriter!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;写入完成&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>BufferedWriter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\ok.txt&quot;</span>;</span><br><span class="line"><span class="comment">//创建BufferedWriter对象</span></span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path));</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;去死吧，IO流！&quot;</span>);</span><br><span class="line">bufferedWriter.close();</span><br></pre></td></tr></table></figure></li></ol><h3 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h3><ol><li>节点流是底层流&#x2F;低级流，直接跟数据源相接</li><li>处理流（包装流）包装节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。</li><li>处理流对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连【模拟修饰器设计模式】</li></ol><h4 id="处理流的功能特定"><a href="#处理流的功能特定" class="headerlink" title="处理流的功能特定"></a>处理流的功能特定</h4><ol><li>性能的提高：主要以增加缓冲的方式来提高输入输出的效率</li><li>操作更便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便</li></ol><blockquote><h4 style="color:green">序列化：在保存数据时，保存数据的值和数据类型</h4><h4 style="color:green">反序列化：在恢复数据时，恢复数据的值和数据类型</h4><h4>让一个类能支持序列化，必须实现<span style="color:red">Serializable</span>或<span style="color:red">Externalizable</span>接口</h4></blockquote><h3 id="输入流-amp-输出流"><a href="#输入流-amp-输出流" class="headerlink" title="输入流&amp;输出流"></a>输入流&amp;输出流</h3><table><thead><tr><th></th><th>类型</th><th>默认设备</th><th>编译类型</th><th>运行类型</th></tr></thead><tbody><tr><td>System.in标准输入</td><td>InputStream</td><td>键盘</td><td>InputStream</td><td>BufferedInputStream</td></tr><tr><td>System.out标准输出</td><td>PrintStream</td><td>显示器</td><td>PrintStream</td><td>PrintStream</td></tr></tbody></table><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><p>字节流与字符流的转换</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示InputStreamReader 转换流解决中文乱码问题</span></span><br><span class="line"><span class="comment"> * 将字节流 FileInputStream 转成字符流 InputStreamReader,指定编码 gbk/utf-8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InputStreamReader_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\test.txt&quot;</span>;</span><br><span class="line">        <span class="comment">//1.将字节流 FileInputStream 转成字符流 InputStreamReader</span></span><br><span class="line">        <span class="comment">//2.指定编码 gbk/utf-8</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//3.把InputStreamReader 传入BufferedReader</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">        <span class="comment">//合并 2、3</span></span><br><span class="line">        <span class="comment">//BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(filePath),&quot;gbk&quot;));</span></span><br><span class="line">        <span class="comment">//4.读取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((s=bufferedReader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示OutputStreamWriter的使用</span></span><br><span class="line"><span class="comment"> * 把一个FileOutputStream 字节流，转为字符流 OutputStreamWriter</span></span><br><span class="line"><span class="comment"> * 指定处理的编码方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutputStreamWriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;D:\\test.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">charset</span> <span class="operator">=</span> <span class="string">&quot;gbk&quot;</span>;</span><br><span class="line">        <span class="type">OutputStreamWriter</span> <span class="variable">outputStreamWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path,<span class="literal">true</span>), charset);</span><br><span class="line">        outputStreamWriter.write(<span class="string">&quot;hello 二狗子&quot;</span>);</span><br><span class="line">        outputStreamWriter.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;按&quot;</span>+charset+<span class="string">&quot;格式保存文件成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p>打印流只有输出流，没有输入流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示PrintStream(字节打印流)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">        out.println(<span class="string">&quot;夏杜键大呆&quot;</span>);</span><br><span class="line">        <span class="comment">//print底层使用的是write,所以也可用直接使用write进行打印</span></span><br><span class="line">        out.write(<span class="string">&quot;夏天天可以&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们可以修改打印流输出的位置/设备</span></span><br><span class="line">        <span class="comment">//输出位置修改</span></span><br><span class="line">        System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;D:\\note.txt&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;我们好久好久没见了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示 PrintWriter 使用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintWriter_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//PrintWriter printWriter = new PrintWriter(System.out);</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;D:\\note.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        printWriter.println(<span class="string">&quot;hi,夏兮&quot;</span>);</span><br><span class="line">        printWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Properties类"><a href="#Properties类" class="headerlink" title="Properties类"></a>Properties类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用Properties类实现文件内容的读取</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//读取mysql.properties文件，并得到ip,username,password</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\com\\xve\\io\\properties\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((line=bufferedReader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//将一行内容以”=“分割</span></span><br><span class="line">        String[] split = line.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="comment">//如果我们要求指定的ip值</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;ip&quot;</span>.equals(split[<span class="number">0</span>])) &#123;</span><br><span class="line">            System.out.println(split[<span class="number">0</span>] + <span class="string">&quot;值为:&quot;</span> + split[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;src\\com\\xve\\io\\properties\\mysql.properties&quot;</span>;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//properties.load(new InputStreamReader(new FileInputStream(filePath)));</span></span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));</span><br><span class="line">    <span class="comment">//把 K-V显示控制台</span></span><br><span class="line">    properties.list(System.out);</span><br><span class="line">    System.out.println(properties.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">    System.out.println(properties.getProperty(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    System.out.println(properties.getProperty(<span class="string">&quot;ip&quot;</span>,<span class="string">&quot;null&quot;</span>));</span><br><span class="line">    properties.setProperty(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;夏杜键&quot;</span>);</span><br><span class="line">    <span class="comment">//comments是注释</span></span><br><span class="line">    properties.store(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath)),<span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(properties.getProperty(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高阶部分"><a href="#高阶部分" class="headerlink" title="高阶部分"></a>高阶部分</h1><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><ol><li><p><strong>网络通信</strong>：通过网络两台设备之间完成数据传输；&#x3D;&#x3D;java.net&#x3D;&#x3D;提供了一系列的类和接口，供程序员使用实现网络通信</p></li><li><p><strong>网络</strong>：两台或多台设备通过一定的物理设备连接起来构成网络</p><ul><li>局域网：覆盖一间房</li><li>城域网：覆盖一个城市</li><li>广域网：覆盖全国甚至全世界–&gt;万维网</li></ul></li><li><p><strong>IP地址</strong>：用以唯一标识网络中唯一的一台主机</p><ul><li>查看ip地址：ipconfig    形式 xx.xx.xx.xx   每一个十进制数范围在0~255</li><li>因为IPv4网络资源受限，所以引入了IPv6替代，当下还未完全替代</li></ul></li><li><p><strong>域名</strong>：方便好记，解决了IP难记的问题</p></li><li><p><strong>端口</strong>：IP+端口访问服务</p></li><li><p><strong>网络协议</strong>：TCP&#x2F;IP协议</p><table><thead><tr><th>OSI模型（理论模型 ）</th><th>TCP&#x2F;IP模型</th><th>TCP&#x2F;IP模型各层对应协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP&#x2F;ftp&#x2F;telnet&#x2F;DNS</td></tr><tr><td>表示层</td><td>应用层</td><td></td></tr><tr><td>会话层</td><td>应用层</td><td></td></tr><tr><td>传输层</td><td>传输层</td><td>TCP&#x2F;UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IP&#x2F;ICMP&#x2F;ARP</td></tr><tr><td>数据链路层</td><td>物理+数据链路层</td><td>Link</td></tr><tr><td>物理层</td><td>物理+数据链路层</td><td></td></tr></tbody></table></li></ol><h3 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress  类"></a>InetAddress  类</h3><ol><li>获取本机的信息【主机名&#x2F;IP】</li><li>通过域名获取远程服务器的IP</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示INetAddress 类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">API_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException &#123;</span><br><span class="line">        <span class="comment">//1.获取本机的InetAddress 对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(localHost);<span class="comment">// LAPTOP-8394T77E/192.168.0.106   ---&gt;  计算机名+IP地址</span></span><br><span class="line">        <span class="comment">//2.根据指定主机名，获取 InetAddress 对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">host</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;LAPTOP-8394T77E&quot;</span>);</span><br><span class="line">        System.out.println(host);</span><br><span class="line">        <span class="comment">//3.根据域名，返回一个 InetAddress 对象</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">baidu</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        System.out.println(baidu);</span><br><span class="line">        <span class="comment">//4. 通过InetAddress 对象获取对应地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">baiduIp</span> <span class="operator">=</span> baidu.getHostAddress();</span><br><span class="line">        System.out.println(baiduIp);</span><br><span class="line">        <span class="comment">//5.通过 InetAddress 对象，获取对应的主机名、或者是域名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">baiduName</span> <span class="operator">=</span> baidu.getHostName();</span><br><span class="line">        System.out.println(baiduName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//www.bilibili.com</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">biliIp</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.bilibili.com&quot;</span>).getHostAddress();</span><br><span class="line">        System.out.println(biliIp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h4 id="TCP编程（可靠的）"><a href="#TCP编程（可靠的）" class="headerlink" title="TCP编程（可靠的）"></a>TCP编程（可靠的）</h4><h5 id="字节读写"><a href="#字节读写" class="headerlink" title="字节读写"></a>字节读写</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.在本机的9999端口监听，等待连接 要求在本机没有其他服务占用9999端口</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器在9999端口等待连接...&quot;</span>);</span><br><span class="line">        <span class="comment">//2.当没有客户端连接9999端口时，程序会阻塞，等待连接</span></span><br><span class="line">        <span class="comment">//  如果有客户端连接，则会返回Socket对象，程序继续</span></span><br><span class="line">        <span class="comment">//  这个ServerSocket 可以通过 accept() 返回多个Socket[多并发]</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端socket=&quot;</span> + accept.getClass());</span><br><span class="line">        <span class="comment">//3.通过socket.getInputStream()读取客户端写入到数据通道的数据</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((l = inputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, <span class="number">0</span>, l));</span><br><span class="line">        &#125;</span><br><span class="line">        accept.shutdownInput();</span><br><span class="line">        <span class="comment">//4.通过socket.getOutputStream()写入到数据通道的数据</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello Client&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        accept.shutdownOutput();</span><br><span class="line">        <span class="comment">//5.关闭流对象和socket</span></span><br><span class="line">        outputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketTCP02Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.连接服务端（ip,端口）</span></span><br><span class="line">        <span class="comment">//  连接本机的9999端口  如果连接成功返回socket对象</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端socket=&quot;</span>+socket.getClass());</span><br><span class="line">        <span class="comment">//2.连接上后，生成Socket，通过socket.getOutputStream()</span></span><br><span class="line">        <span class="comment">//  得到和socket关联的输出流对象</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.通过输出流，写入数据到 数据通道</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello Server&quot;</span>.getBytes());</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">//4.通过输入流，读取数据 输出</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((l=inputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bytes,<span class="number">0</span>,l));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownInput();</span><br><span class="line">        <span class="comment">//5.关闭流对象和socket</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>同时也可以用&#x3D;&#x3D;字符流&#x3D;&#x3D;进行读写，需要注意的时，进行结束标记时可以使用 writer.newline()和readLine()搭配</p><h5 id="文件拷贝案例"><a href="#文件拷贝案例" class="headerlink" title="文件拷贝案例"></a>文件拷贝案例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPFileCopyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器启动&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//1.前期准备 复制文件目的路径 各种流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;src\\1.jpg&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(accept.getInputStream());</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath));</span><br><span class="line">        <span class="comment">//2.读取socket传输过来的文件并输出</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((i=bufferedInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(bytes,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        accept.shutdownInput();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        <span class="comment">//3.回复收到图片</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(accept.getOutputStream()));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;收到图片&quot;</span>);</span><br><span class="line">        bufferedWriter.flush();</span><br><span class="line">        accept.shutdownOutput();</span><br><span class="line">        <span class="comment">//4.关闭流和socket</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        accept.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPFileCopyClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//连接服务器 localhost:9999</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(),<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端启动&quot;</span>);</span><br><span class="line">        <span class="comment">//1.准备文件来源、以及所需要的流 字节流</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\1.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">//FileInputStream inputStream = new FileInputStream(filePath);</span></span><br><span class="line">        <span class="comment">//OutputStream outputStream = socket.getOutputStream();</span></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(socket.getOutputStream());</span><br><span class="line">        <span class="comment">//2.传输文件</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((i=bufferedInputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(bytes,<span class="number">0</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">//3.接收回复</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream()));</span><br><span class="line">        System.out.println(bufferedReader.readLine());</span><br><span class="line">        <span class="comment">//socket.shutdownInput();</span></span><br><span class="line">        <span class="comment">//4.传输结束关闭流与socket</span></span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="netstat指令"><a href="#netstat指令" class="headerlink" title="netstat指令"></a>netstat指令</h5><ol><li>netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况</li><li>netstat -am|more 可以分页显示</li><li>要求在dos控制台执行</li><li>netstat -anb 可以查看端口监听的同时查看到是谁在监听使用（管理员模式下）</li></ol><h4 id="UDP编程（不可靠的）"><a href="#UDP编程（不可靠的）" class="headerlink" title="UDP编程（不可靠的）"></a>UDP编程（不可靠的）</h4><ol><li>没有明确的服务端和客户端，演变成数据的发送端和接收端</li><li>接收数据和发送数据是通过&#x3D;&#x3D;DatagramSocket&#x3D;&#x3D;对象完成</li><li>将数据封装到&#x3D;&#x3D;DatagramPacket&#x3D;&#x3D; 对象、封包</li><li>当接收到 DatagramPacket对象，需要进行拆包，取出对象</li><li>DatagramSocket可以指定在哪个端口接收数据</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiverA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建一个DatagramSocket 对象，准备在9999接收数据</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//2.构建一个DatagramPacket,用以接收数据  在前面讲解时UDP数据包最大是64kb</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length);</span><br><span class="line">        <span class="comment">//3.准备接收数据，调用接收方法 ,将网络传输的DatagramPacket对象填充到datagramPacket对象中</span></span><br><span class="line">        <span class="comment">// 当有数据包发送到本地端口，会接收数据，当没有数据发送到本地，就会阻塞在这里</span></span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        <span class="comment">//4.对datagramPacket进行拆包，取出数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> datagramPacket.getLength();<span class="comment">//实际接收到的数据字节长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = datagramPacket.getData();<span class="comment">//接收到的数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,l));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="string">&quot;好的，明天见&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(b,b.length, InetAddress.getByName(<span class="string">&quot;192.168.0.106&quot;</span>),<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//3.将datagramPacket通过网络传输到指定端口</span></span><br><span class="line">        datagramSocket.send(datagramPacket1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.关闭资源</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;A端退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSenderB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.创建DatagramSocket 对象</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="comment">//2.将需要发送的数据封装到datagramPacket对象中</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="string">&quot;hello 明天吃火锅去&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length, InetAddress.getByName(<span class="string">&quot;192.168.0.106&quot;</span>),<span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//3.将datagramPacket通过网络传输到指定端口</span></span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当有数据包发送到本地端口，会接收数据，当没有数据发送到本地，就会阻塞在这里</span></span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        <span class="comment">//4.对datagramPacket进行拆包，取出数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> datagramPacket.getLength();<span class="comment">//实际接收到的数据字节长度</span></span><br><span class="line">        <span class="type">byte</span>[] data = datagramPacket.getData();<span class="comment">//接收到的数据</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,l));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭资源</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;B端退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>在不修改源码情况下，来控制程序，符合设计模式的OCP原则（开闭原则：不修改源码，扩容功能）；依靠反射创建出诸多框架</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//正常调用对象</span></span><br><span class="line"><span class="comment">//        Cat cat = new Cat();</span></span><br><span class="line"><span class="comment">//        cat.hi();</span></span><br><span class="line">        <span class="comment">//使用配置文件读取</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\com\\xve\\reflect\\question\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;classfullpath&quot;</span>);</span><br><span class="line">        System.out.println(classfullpath);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        System.out.println(methodName);</span><br><span class="line">        <span class="comment">//利用反射机制解决</span></span><br><span class="line">        <span class="comment">//1.加载类 返回一个Class类型的对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//2.通过 cls得到加载的类对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(o.getClass());</span><br><span class="line">        <span class="comment">//3.通过cls得到加载的类 的对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//4.调用 调用方法对象来实现调用方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>​&#x3D;&#x3D;反射机制&#x3D;&#x3D;允许程序在执行期借助于ReflectionAPI取得任何类的内部信息（比如成员变量，构造器，成员方法等等）并能操作对象的属性及方法，反射在设计模式和框架底层都会用用到</p><p><img src="D:\Data\Typora\资料库\图纸\JAVA反射机制.jpg"></p><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>​加载完类之后，在堆中就产生了一个class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，通过这个对象得到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为反射</p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>&#x3D;&#x3D;类加载的五个阶段&#x3D;&#x3D;</p><p><img src="D:\Data\Typora\资料库\图纸\类加载五个阶段.jpg"></p><ol><li><strong>加载阶段</strong>：将字节码从不同的数据源（可能是class文件、也可能是jar包、甚至网络）转化为二进制字节流加载到内存中，并生成一个代表该类的java.lang.class对象</li><li><strong>连接阶段</strong>：<ul><li>验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全（文件格式验证，元数据验证，字节码验证，符号引用验证）&#x3D;&#x3D;可以使用-Xverify:none关闭大部分的类验证措施&#x3D;&#x3D;</li><li>准备：JVM会在该阶段对静态变量，分配内存并默认初始化.</li><li>解析：虚拟机将常量池内的符号引用替换为直接引用的过程.</li></ul></li><li><strong>初始化阶段</strong>：初始化阶段。才真正开始执行类中定义的Java程序代码，此阶段是执行<clinit>()方法的过程，该方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有&#x3D;&#x3D;静态变量&#x3D;&#x3D;的赋值动作和&#x3D;&#x3D;静态代码块&#x3D;&#x3D;中的语句，并进行合并。虚拟机会保证一个类的<clinit>()方法在多线程环境中正确的加锁，同步，多个线程同时调用，那么只有一个方法会去执行，其他线程阻塞等待</li></ol><h3 id="反射获取类的结构信息"><a href="#反射获取类的结构信息" class="headerlink" title="反射获取类的结构信息"></a>反射获取类的结构信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xve.reflect.classload_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xve.reflect.question.Cat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种方法API</span></span><br><span class="line">    <span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; pClass = Class.forName(<span class="string">&quot;com.xve.reflect.classload_.P&quot;</span>);</span><br><span class="line">        <span class="comment">//获取全类名</span></span><br><span class="line">        System.out.println(pClass.getName());</span><br><span class="line">        <span class="comment">//获取简单类名</span></span><br><span class="line">        System.out.println(pClass.getSimpleName());</span><br><span class="line">        <span class="comment">//获取所有public修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = pClass.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field: fields) &#123;</span><br><span class="line">            System.out.print(field.getName()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = pClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.print(declaredField.getName() +<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取所有public修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = pClass.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.print(method.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = pClass.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.print(declaredMethod.getName()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取所有public修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = pClass.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.print(constructor.getName() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取本类所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = pClass.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.print(declaredConstructor.getName()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//以Package形式返回 包信息</span></span><br><span class="line">        System.out.println(pClass.getPackage());</span><br><span class="line">        <span class="comment">//以Class形式返回父类信息</span></span><br><span class="line">        System.out.println(pClass.getSuperclass());</span><br><span class="line">        <span class="comment">//以Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = pClass.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.print(anInterface.getName()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//以Annotation[]形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = pClass.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.print(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种方法</span></span><br><span class="line">    <span class="meta">@org</span>.junit.jupiter.api.Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; pClass = Class.forName(<span class="string">&quot;com.xve.reflect.classload_.P&quot;</span>);</span><br><span class="line">        <span class="comment">//getModifiers:以int形式返回修饰符</span></span><br><span class="line">        <span class="comment">//【说明】默认修饰符:0   public:1    private:2   protected:4     static:8    final:16    [public+static = 9]</span></span><br><span class="line">        Field[] declaredFields = pClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">//getType:以Class形式返回类型</span></span><br><span class="line">        <span class="comment">//getName:返回属性名</span></span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类种所有属性=&quot;</span>+declaredField.getName()</span><br><span class="line">            +<span class="string">&quot;该属性的修饰符值=&quot;</span>+declaredField.getModifiers()</span><br><span class="line">            +<span class="string">&quot;该属性的类型=&quot;</span>+declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//属性如此方法也如此，方法比属性多一个返回值方法,参数方法 </span></span><br><span class="line">        <span class="comment">//Class getReturnType(); </span></span><br><span class="line">        <span class="comment">//Class[] getParamenterTypes():</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String hobby;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    String job;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> sal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.class;<span class="comment">//代表一个类</span></span><br><span class="line">java.lang.reflect.Field;<span class="comment">//代表成员属性</span></span><br><span class="line">java.lang.reflect.Method;<span class="comment">//代表类的方法</span></span><br><span class="line">java.lang.reflect.Constructor;<span class="comment">//代表类的构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\com\\xve\\reflect\\question\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;classfullpath&quot;</span>);</span><br><span class="line">        <span class="comment">//反射相关的四个主要的类</span></span><br><span class="line">        <span class="comment">//1.Class</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//2.属性 公共属性直接可以获取，私有属性需添加get方法</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;name&quot;</span>);<span class="comment">//成员变量名</span></span><br><span class="line">        <span class="comment">//3.方法 </span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;hi&quot;</span>);<span class="comment">//方法名</span></span><br><span class="line">        <span class="comment">//4.构造方法 分为有参无参</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor2</span> <span class="operator">=</span> cls.getConstructor(String.class);</span><br></pre></td></tr></table></figure><h3 id="反射调用性能优化"><a href="#反射调用性能优化" class="headerlink" title="反射调用性能优化"></a>反射调用性能优化</h3><p>反射优点：动态创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支持</p><p>反射缺点：使用反射基本是解释执行，对执行速度有影响</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    m01();<span class="comment">//-&gt;0</span></span><br><span class="line">    m02();<span class="comment">//-&gt;15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传统方法调用hi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">500</span>;i++)&#123;</span><br><span class="line">        cat.hi();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;传统方法结果运行时间:&quot;</span>+(end-start));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反射机制调用方法hi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m02</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">aClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.xve.reflect.question.Cat&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">500</span>;i++)&#123;</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;反射方法结果运行时间:&quot;</span>+(end-start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭访问检查提高性能"><a href="#关闭访问检查提高性能" class="headerlink" title="关闭访问检查提高性能"></a>关闭访问检查提高性能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.setAccessible(<span class="literal">true</span>);<span class="comment">//true 关闭访问检查 适用于成员变量，方法，构造方法</span></span><br></pre></td></tr></table></figure><h3 id="Class类常用方法"><a href="#Class类常用方法" class="headerlink" title="Class类常用方法"></a>Class类常用方法</h3><p><img src="D:\Data\Typora\资料库\图纸\Class.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.xve.reflect.clas.Car&quot;</span>;</span><br><span class="line">    <span class="comment">//1.获取到Car类 对应的Class对象  &lt;?&gt;表示不确定的Java类型</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(classAllPath);</span><br><span class="line">    <span class="comment">//2.输出aClass</span></span><br><span class="line">    System.out.println(aClass);<span class="comment">//显示aClass对象，是哪一个类的对象 class com.xve.reflect.clas.Car</span></span><br><span class="line">    System.out.println(aClass.getClass());<span class="comment">//显示cls运行类型 class java.lang.Class</span></span><br><span class="line">    <span class="comment">//3.得到包名</span></span><br><span class="line">    System.out.println(aClass.getPackage());<span class="comment">//显示对象所在包 package com.xve.reflect.clas</span></span><br><span class="line">    <span class="comment">//4.类名</span></span><br><span class="line">    System.out.println(aClass.getName());<span class="comment">//得到全限定类名 com.xve.reflect.clas.Car</span></span><br><span class="line">    <span class="comment">//5.通过aClass创建对象实例</span></span><br><span class="line">    <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) aClass.newInstance();</span><br><span class="line">    System.out.println(car);<span class="comment">//输出对象的toString方法 Car&#123;brand=&#x27;路虎&#x27;, price=1000, color=&#x27;灰色&#x27;&#125;</span></span><br><span class="line">    <span class="comment">//6.通过反射获取属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> aClass.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">    System.out.println(field.get(car));<span class="comment">//输出 路虎</span></span><br><span class="line">    <span class="comment">//7.通过反射给属性赋值</span></span><br><span class="line">    field.set(car,<span class="string">&quot;宝马&quot;</span>);</span><br><span class="line">    System.out.println(field.get(car));<span class="comment">//输出 宝马</span></span><br><span class="line">    <span class="comment">//8.遍历得到所有属性</span></span><br><span class="line">    Field[] fields = aClass.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">        System.out.print(f.get(car)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取Class对象的六种方式"><a href="#获取Class对象的六种方式" class="headerlink" title="获取Class对象的六种方式"></a>获取Class对象的六种方式</h4><ol><li>代码阶段&#x2F;编译阶段 Class.forName()</li><li>类加载器</li><li>Class类阶段（加载阶段） 类.class</li><li>Runtime运行阶段 对象.getClass()</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. Class.forName</span></span><br><span class="line"><span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;com.xve.reflect.clas.Car&quot;</span>;<span class="comment">//通过读取配置文件获取</span></span><br><span class="line">Class&lt;?&gt; cls1 = Class.forName(classPath);</span><br><span class="line">System.out.println(cls1);</span><br><span class="line"><span class="comment">//2. 通过类名.class 多用于参数的传递</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cls2</span> <span class="operator">=</span> Car.class;</span><br><span class="line">System.out.println(cls2);</span><br><span class="line"><span class="comment">//3. 已知对象实例，通过对象实例.getClass()</span></span><br><span class="line"><span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">cls3</span> <span class="operator">=</span> car.getClass();</span><br><span class="line">System.out.println(cls3);</span><br><span class="line"><span class="comment">//4.通过类加载器【4种】来获取到类的Class对象</span></span><br><span class="line"><span class="comment">//(1)先得到类加载器 car</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> car.getClass().getClassLoader();</span><br><span class="line"><span class="comment">//(2)通过类加载器得到Class对象</span></span><br><span class="line">Class&lt;?&gt; cls4 = classLoader.loadClass(classPath);</span><br><span class="line">System.out.println(cls4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上四种是同一个Class hashCode地址一样</span></span><br><span class="line">System.out.println(cls1.hashCode());</span><br><span class="line">System.out.println(cls2.hashCode());</span><br><span class="line">System.out.println(cls3.hashCode());</span><br><span class="line">System.out.println(cls4.hashCode());</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 基本数据(int,boolean,float,double,byte,long,short)按如下方式得到Class类对象</span></span><br><span class="line">Class&lt;Integer&gt; integerClass = <span class="type">int</span>.class;</span><br><span class="line">System.out.println(integerClass);</span><br><span class="line"><span class="comment">//6.基本数据包装类型，可以通过.type得到Class对象</span></span><br><span class="line">Class&lt;Integer&gt; type = Integer.TYPE;</span><br><span class="line">System.out.println(type);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以根据以下hashCode值推测出，Integer和int底层是一致的</span></span><br><span class="line">System.out.println(integerClass.hashCode());</span><br><span class="line">System.out.println(type.hashCode());</span><br></pre></td></tr></table></figure><h4 id="拥有Class对象的类型"><a href="#拥有Class对象的类型" class="headerlink" title="拥有Class对象的类型"></a>拥有Class对象的类型</h4><ol><li>外部类，成员内部类，静态内部类，局部内部类，匿名内部类</li><li>interface：接口</li><li>数组</li><li>enum：枚举</li><li>annotation：注解</li><li>基本数据类型</li><li>void</li></ol><h3 id="反射爆破"><a href="#反射爆破" class="headerlink" title="反射爆破"></a>反射爆破</h3><ol><li>调用类中的无参构造器</li><li>调用类中的指定构造器</li><li>Class类相关方法：<ul><li>newInstance：调用类中的无参构造器，获取对应类的对象</li><li>getConstructor(Class…clazz)：根据参数列表，调用对应的public构造器</li><li>getDecalaredConstructor(Class…clazz)：根据参数列表，获取对应的所有构造器对象</li></ul></li><li>Constructor类相关方法<ul><li>setAccessible：暴破</li><li>newInstance(Object…obj)：调用构造器</li></ul></li></ol><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>略</p><h2 id="JDBC和连接池"><a href="#JDBC和连接池" class="headerlink" title="JDBC和连接池"></a>JDBC和连接池</h2><h3 id="JDBC概述"><a href="#JDBC概述" class="headerlink" title="JDBC概述"></a>JDBC概述</h3><p>JDBC是为了访问不同的数据库，提供了一个统一接口</p><p><img src="D:\Data\Typora\资料库\图纸\JDBC原理.jpg"></p><h3 id="JDBC快速入门"><a href="#JDBC快速入门" class="headerlink" title="JDBC快速入门"></a>JDBC快速入门</h3><ol><li>注册驱动-加载Driver类</li><li>获取连接-得到Connection</li><li>执行增删改查-发送SQL</li><li>释放资源-关闭相关连接</li></ol><h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><p>JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行SQL语句，并得到返回结果等各类操作，相关类和接口在java.sql与javax.sql包中</p><h3 id="JDBCUtils"><a href="#JDBCUtils" class="headerlink" title="JDBCUtils"></a>JDBCUtils</h3><p>封装建立连接和关闭连接的代码的工具类，减少代码的冗余</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>connection.setAutoCommit(false)&#x2F;&#x2F;关闭自动提交事务，之后可以写事务内容</p><p>connection.commit() &#x2F;&#x2F;提交事务</p><p>connection.rollback()&#x2F;&#x2F;事务回滚</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，采用java的批量更新机制，允许一次性提交多条sql语句</p><ol><li>addBatch()：添加需要批量处理的SQL语句或参数</li><li>execute Batch()：执行批量处理语句</li><li>clearBatch()：清空批处理包的语句</li></ol><p>JDBC连接MySQL时，如果需要使用批处理功能，请在url中加入参数&#x3D;&#x3D;?rewriteBatchedStatement&#x3D;true&#x3D;&#x3D;</p><p>批处理通常和PreparedStatement一起搭配使用，预处理可以减少编译次数，减少运行次数，效率提高</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><h3 id="Apache-DBUtils"><a href="#Apache-DBUtils" class="headerlink" title="Apache-DBUtils"></a>Apache-DBUtils</h3><h3 id="DAO增删改查-BasicDao"><a href="#DAO增删改查-BasicDao" class="headerlink" title="DAO增删改查-BasicDao"></a>DAO增删改查-BasicDao</h3><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>快速入门</p><p>正则表达式基本语法</p><p>三个常用类</p><p>分组、捕获、反向引用</p><p>元字符</p><p>应用实例</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于o{0,}</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td></tr><tr><td>(?:pattern)</td><td>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</td></tr><tr><td>(?&#x3D;pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?&#x3D;95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;&#x3D;pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配</td></tr><tr><td>x|y</td><td>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何可见字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td></tr></tbody></table><h2 id="项目开发流程"><a href="#项目开发流程" class="headerlink" title="项目开发流程"></a>项目开发流程</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><h3 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h3><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><h3 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h3><h3 id="维护阶段"><a href="#维护阶段" class="headerlink" title="维护阶段"></a>维护阶段</h3>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习清单</title>
      <link href="/2022/10/06/note/LearningChecklist/"/>
      <url>/2022/10/06/note/LearningChecklist/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ul><li><input disabled="" type="checkbox"> 数据结构（**JAVA数据结构 + 王道）</li><li><input disabled="" type="checkbox"> 计算机组成（王道）</li><li><input disabled="" type="checkbox"> 计算机操作系统（王道）</li><li><input disabled="" type="checkbox"> 计算机网络（王道 + 图解HTTP）</li><li><input disabled="" type="checkbox"> 设计模式 （大话设计模式+《设计模式 可复用面向对象软件的基础》）</li></ul><h1 id="JAVA技术"><a href="#JAVA技术" class="headerlink" title="JAVA技术"></a>JAVA技术</h1><ul><li><input disabled="" type="checkbox"> 反射机制</li><li><input disabled="" type="checkbox"> IO</li><li><input disabled="" type="checkbox"> 多线程</li><li><input disabled="" type="checkbox"> 高并发</li></ul><h1 id="系统架构师（优先）"><a href="#系统架构师（优先）" class="headerlink" title="系统架构师（优先）"></a>系统架构师（优先）</h1><ul><li><input disabled="" type="checkbox"> Docker</li><li><input disabled="" type="checkbox"> VMware</li></ul><h1 id="微服务技术"><a href="#微服务技术" class="headerlink" title="微服务技术"></a>微服务技术</h1><ul><li><input disabled="" type="checkbox"> 1、服务注册发现： Nacos</li><li><input disabled="" type="checkbox"> 2、服务配置中心： Nacos</li><li><input disabled="" type="checkbox"> 3、服务网关：Spring Cloud Gateway</li><li><input disabled="" type="checkbox"> 4、熔断限流： Sentinel</li><li><input disabled="" type="checkbox"> 5、服务监控： Spring Boot Admin</li><li><input disabled="" type="checkbox"> 6、分布式数据库：RDS</li><li><input disabled="" type="checkbox"> 7、分布式缓存：Redis</li><li><input disabled="" type="checkbox"> 8、分布式文件： Minio</li><li><input disabled="" type="checkbox"> 9、分布式事务： Seata</li><li><input disabled="" type="checkbox"> 10、链路跟踪：SkyWarking</li><li><input disabled="" type="checkbox"> 11、分布式日志：ELK（Elasticsearch , Logstash, Kibana）</li><li><input disabled="" type="checkbox"> 12、容器云：kubernetes、Rancher</li><li><input disabled="" type="checkbox"> 13、CI&#x2F;CD持续集成&#x2F;部署：Jenkins</li><li><input disabled="" type="checkbox"> 14、代码仓库：GitLab</li><li><input disabled="" type="checkbox"> 15、镜像仓库：Harbor</li><li><input disabled="" type="checkbox"> <span style="color:red">16、XHP摄影网站</span></li></ul>]]></content>
      
      
      <categories>
          
          <category> 个人清单 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 清单 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/05/26/hello-world/"/>
      <url>/2017/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 试试 </tag>
            
            <tag> 就 </tag>
            
            <tag> 逝世 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
